

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.GitHttp = factory());
})(this, (function () { 'use strict';

  // --- 1. 傻瓜式 Headers 解析器 ---
  // 不依赖 .entries()，也不依赖迭代器，使用最原始的遍历方法
  function normalizeHeaders(headers) {
    const result = {};

    if (!headers) return result;

    // 情况 A: 标准 Headers 对象 (有 forEach)
    if (typeof headers.forEach === 'function') {
      headers.forEach((value, key) => {
        result[key.toLowerCase()] = value;
      });
    }
    // 情况 B: 普通 Object (Overleaf 返回这种)
    else {
      for (const key in headers) {
        // 安全检查，防止遍历到原型链属性
        if (Object.prototype.hasOwnProperty.call(headers, key)) {
          result[key.toLowerCase()] = headers[key];
        }
      }
    }

    return result;
  }

  // --- 2. 核心请求函数 ---
  async function request({ url, method, headers, body }) {

    // 处理请求体 (Push 时用到)
    let fetchBody = body;
    if (body) {
        // 如果是 Async Iterator 或 Array，强制转为 Uint8Array
        const chunks = [];
        if (body[Symbol.asyncIterator]) {
            for await (const chunk of body) chunks.push(chunk);
        } else if (body[Symbol.iterator]) {
            for (const chunk of body) chunks.push(chunk);
        } else if (Array.isArray(body)) {
             chunks.push(...body);
        }

        if (chunks.length > 0) {
            const totalLen = chunks.reduce((acc, c) => acc + c.length, 0);
            const merged = new Uint8Array(totalLen);
            let offset = 0;
            for (const chunk of chunks) {
                merged.set(chunk, offset);
                offset += chunk.length;
            }
            fetchBody = merged;
        }
    }

    // 发起请求
    const res = await fetch(url, { method, headers, body: fetchBody });

    // 处理响应体
    const buffer = await res.arrayBuffer();
    const uint8Array = new Uint8Array(buffer);

    // 构造兼容的手动迭代器
    const manualIterator = {
      consumed: false,
      [Symbol.asyncIterator]() { return this; },
      next() {
        if (this.consumed) return Promise.resolve({ value: undefined, done: true });
        this.consumed = true;
        return Promise.resolve({ value: uint8Array, done: false });
      }
    };

    return {
      url: res.url,
      method: res.type,
      statusCode: res.status,
      statusMessage: res.statusText,
      // 【关键】使用我们上面写的傻瓜式解析器
      headers: normalizeHeaders(res.headers),
      body: manualIterator
    };
  }

  return { request };

}));