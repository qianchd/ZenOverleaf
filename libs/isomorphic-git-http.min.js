(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.GitHttp = factory());
})(this, (function () { 'use strict';

  // --- 1. Foolproof Headers Parser ---
  // Does not rely on .entries() or iterators; uses the most primitive traversal method
  function normalizeHeaders(headers) {
    const result = {};

    if (!headers) return result;

    // Case A: Standard Headers object (has forEach)
    if (typeof headers.forEach === 'function') {
      headers.forEach((value, key) => {
        result[key.toLowerCase()] = value;
      });
    }
    // Case B: Plain Object (Overleaf returns this type)
    else {
      for (const key in headers) {
        // Safety check, prevents traversing prototype chain properties
        if (Object.prototype.hasOwnProperty.call(headers, key)) {
          result[key.toLowerCase()] = headers[key];
        }
      }
    }

    return result;
  }

  // --- 2. Core Request Function ---
  async function request({ url, method, headers, body }) {

    // Process request body (used during Push)
    let fetchBody = body;
    if (body) {
        // If it is an Async Iterator or Array, forcibly convert to Uint8Array
        const chunks = [];
        if (body[Symbol.asyncIterator]) {
            for await (const chunk of body) chunks.push(chunk);
        } else if (body[Symbol.iterator]) {
            for (const chunk of body) chunks.push(chunk);
        } else if (Array.isArray(body)) {
             chunks.push(...body);
        }

        if (chunks.length > 0) {
            const totalLen = chunks.reduce((acc, c) => acc + c.length, 0);
            const merged = new Uint8Array(totalLen);
            let offset = 0;
            for (const chunk of chunks) {
                merged.set(chunk, offset);
                offset += chunk.length;
            }
            fetchBody = merged;
        }
    }

    // Initiate request
    const res = await fetch(url, { method, headers, body: fetchBody });

    // Process response body
    const buffer = await res.arrayBuffer();
    const uint8Array = new Uint8Array(buffer);

    // Construct a compatible manual iterator
    const manualIterator = {
      consumed: false,
      [Symbol.asyncIterator]() { return this; },
      next() {
        if (this.consumed) return Promise.resolve({ value: undefined, done: true });
        this.consumed = true;
        return Promise.resolve({ value: uint8Array, done: false });
      }
    };

    return {
      url: res.url,
      method: res.type,
      statusCode: res.status,
      statusMessage: res.statusText,
      // [CRITICAL] Use the foolproof parser defined above
      headers: normalizeHeaders(res.headers),
      body: manualIterator
    };
  }

  return { request };

}));