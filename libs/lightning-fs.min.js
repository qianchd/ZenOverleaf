(function(global) {
  'use strict';

  // --- Fixed MemoryStat ---
  // Added Date objects for mtime, ctime, etc. to solve "n is undefined" error
  class MemoryStat {
      constructor(type, size) {
          this.type = type;
          this.size = size;

          const now = Date.now();
          this.mtimeMs = now;
          this.ctimeMs = now;
          this.atimeMs = now;

          // [Core Fix] Git requires these properties to be Date objects, otherwise calling .valueOf() will throw an error
          this.mtime = new Date(now);
          this.ctime = new Date(now);
          this.atime = new Date(now);

          // File: 33188 (0o100644), Directory: 16877 (0o40755)
          this.mode = type === 'dir' ? 16877 : 33188;
          this.uid = 1;
          this.gid = 1;
          this.dev = 1;
          this.ino = Math.floor(Math.random() * 100000) + 1;
      }
      isDirectory() { return this.type === 'dir'; }
      isFile() { return this.type === 'file'; }
      isSymbolicLink() { return false; }
  }

  // Pure in-memory version of LightningFS
  class LightningFS {
    constructor(name) {
        this.name = name;
        // Use window global variable to store data
        // If name changes on each init (we used a random name in content.js), this will be empty, ensuring a clean state
        if (!window._lfs_ram_storage) window._lfs_ram_storage = {};

        if (!window._lfs_ram_storage[name]) {
            window._lfs_ram_storage[name] = {
                files: new Map(),
                dirs: new Map([['/', true]])
            };
        }
        this.store = window._lfs_ram_storage[name];

        this.promises = {
            init: async () => {},
            activate: async () => {},
            deactivate: async () => {},

            mkdir: async (path) => {
                if (path.length > 1 && path.endsWith('/')) path = path.slice(0, -1);
                if (this.store.dirs.has(path)) {
                    const err = new Error("EEXIST");
                    err.code = "EEXIST";
                    throw err;
                }
                this.store.dirs.set(path, true);
            },

            rmdir: async (path) => {
                if (!this.store.dirs.has(path)) {
                    const err = new Error("ENOENT");
                    err.code = "ENOENT";
                    throw err;
                }
                for (const f of this.store.files.keys()) {
                    if (f.startsWith(path + '/')) throw { code: 'ENOTEMPTY' };
                }
                this.store.dirs.delete(path);
            },

            readdir: async (path) => {
               if (path.length > 1 && path.endsWith('/')) path = path.slice(0, -1);
               if (!this.store.dirs.has(path)) {
                   const err = new Error("ENOENT");
                   err.code = "ENOENT";
                   throw err;
               }
               const names = new Set();
               const prefix = path === '/' ? '/' : path + '/';

               for (const f of this.store.files.keys()) {
                   if (f.startsWith(prefix)) {
                       const sub = f.substring(prefix.length);
                       const nextSlash = sub.indexOf('/');
                       if (nextSlash === -1) names.add(sub);
                       else names.add(sub.substring(0, nextSlash));
                   }
               }
               for (const d of this.store.dirs.keys()) {
                   if (d !== path && d.startsWith(prefix)) {
                       const sub = d.substring(prefix.length);
                       const nextSlash = sub.indexOf('/');
                       if (nextSlash === -1) names.add(sub);
                       else names.add(sub.substring(0, nextSlash));
                   }
               }
               return Array.from(names);
            },

            writeFile: async (path, data, opts) => {
                if (typeof data === 'string') {
                    data = new TextEncoder().encode(data);
                }
                this.store.files.set(path, data);
                this.store.dirs.delete(path);
            },

            readFile: async (path, opts) => {
                if (!this.store.files.has(path)) {
                    const err = new Error("ENOENT");
                    err.code = "ENOENT";
                    throw err;
                }
                const data = this.store.files.get(path);
                if (opts === 'utf8' || (opts && opts.encoding === 'utf8')) {
                    return new TextDecoder().decode(data);
                }
                return data;
            },

            unlink: async (path) => {
                 if (!this.store.files.has(path)) {
                    const err = new Error("ENOENT");
                    err.code = "ENOENT";
                    throw err;
                 }
                 this.store.files.delete(path);
            },

            stat: async (path) => {
                if (path.length > 1 && path.endsWith('/')) path = path.slice(0, -1);

                if (this.store.files.has(path)) {
                    return new MemoryStat('file', this.store.files.get(path).length);
                }
                if (this.store.dirs.has(path)) {
                    return new MemoryStat('dir', 0);
                }
                const err = new Error("ENOENT");
                err.code = "ENOENT";
                throw err;
            },

            lstat: async (path) => this.promises.stat(path),
            readlink: async (path) => { throw { code: 'ENOENT' }; },
            symlink: async () => {},
            backFile: async () => {}
        };

        for (const key in this.promises) {
            this.promises[key] = this.promises[key].bind(this);
        }
    }
  }

  global.LightningFS = LightningFS;

})(self);