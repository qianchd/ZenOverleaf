(function(global) {
  'use strict';

  // --- 修复版 MemoryStat ---
  // 增加了 mtime, ctime 等 Date 对象，解决 "n is undefined" 错误
  class MemoryStat {
     constructor(type, size) {
         this.type = type;
         this.size = size;

         const now = Date.now();
         this.mtimeMs = now;
         this.ctimeMs = now;
         this.atimeMs = now;

         // 【核心修复】Git 需要这些属性是 Date 对象，否则调用 .valueOf() 会报错
         this.mtime = new Date(now);
         this.ctime = new Date(now);
         this.atime = new Date(now);

         // 文件: 33188 (0o100644), 目录: 16877 (0o40755)
         this.mode = type === 'dir' ? 16877 : 33188;
         this.uid = 1;
         this.gid = 1;
         this.dev = 1;
         this.ino = Math.floor(Math.random() * 100000) + 1;
     }
     isDirectory() { return this.type === 'dir'; }
     isFile() { return this.type === 'file'; }
     isSymbolicLink() { return false; }
  }

  // 纯内存版 LightningFS
  class LightningFS {
    constructor(name) {
        this.name = name;
        // 使用 window 全局变量存储数据
        // 每次初始化如果 name 变了（我们在 content.js 用了随机名），这里就是空的，保证干净
        if (!window._lfs_ram_storage) window._lfs_ram_storage = {};

        if (!window._lfs_ram_storage[name]) {
            window._lfs_ram_storage[name] = {
                files: new Map(),
                dirs: new Map([['/', true]])
            };
        }
        this.store = window._lfs_ram_storage[name];

        this.promises = {
            init: async () => {},
            activate: async () => {},
            deactivate: async () => {},

            mkdir: async (path) => {
                if (path.length > 1 && path.endsWith('/')) path = path.slice(0, -1);
                if (this.store.dirs.has(path)) {
                    const err = new Error("EEXIST");
                    err.code = "EEXIST";
                    throw err;
                }
                this.store.dirs.set(path, true);
            },

            rmdir: async (path) => {
                if (!this.store.dirs.has(path)) {
                    const err = new Error("ENOENT");
                    err.code = "ENOENT";
                    throw err;
                }
                for (const f of this.store.files.keys()) {
                    if (f.startsWith(path + '/')) throw { code: 'ENOTEMPTY' };
                }
                this.store.dirs.delete(path);
            },

            readdir: async (path) => {
               if (path.length > 1 && path.endsWith('/')) path = path.slice(0, -1);
               if (!this.store.dirs.has(path)) {
                    const err = new Error("ENOENT");
                    err.code = "ENOENT";
                    throw err;
               }
               const names = new Set();
               const prefix = path === '/' ? '/' : path + '/';

               for (const f of this.store.files.keys()) {
                   if (f.startsWith(prefix)) {
                       const sub = f.substring(prefix.length);
                       const nextSlash = sub.indexOf('/');
                       if (nextSlash === -1) names.add(sub);
                       else names.add(sub.substring(0, nextSlash));
                   }
               }
               for (const d of this.store.dirs.keys()) {
                   if (d !== path && d.startsWith(prefix)) {
                       const sub = d.substring(prefix.length);
                       const nextSlash = sub.indexOf('/');
                       if (nextSlash === -1) names.add(sub);
                       else names.add(sub.substring(0, nextSlash));
                   }
               }
               return Array.from(names);
            },

            writeFile: async (path, data, opts) => {
                if (typeof data === 'string') {
                    data = new TextEncoder().encode(data);
                }
                this.store.files.set(path, data);
                this.store.dirs.delete(path);
            },

            readFile: async (path, opts) => {
                if (!this.store.files.has(path)) {
                    const err = new Error("ENOENT");
                    err.code = "ENOENT";
                    throw err;
                }
                const data = this.store.files.get(path);
                if (opts === 'utf8' || (opts && opts.encoding === 'utf8')) {
                    return new TextDecoder().decode(data);
                }
                return data;
            },

            unlink: async (path) => {
                 if (!this.store.files.has(path)) {
                    const err = new Error("ENOENT");
                    err.code = "ENOENT";
                    throw err;
                 }
                 this.store.files.delete(path);
            },

            stat: async (path) => {
                if (path.length > 1 && path.endsWith('/')) path = path.slice(0, -1);

                if (this.store.files.has(path)) {
                    return new MemoryStat('file', this.store.files.get(path).length);
                }
                if (this.store.dirs.has(path)) {
                    return new MemoryStat('dir', 0);
                }
                const err = new Error("ENOENT");
                err.code = "ENOENT";
                throw err;
            },

            lstat: async (path) => this.promises.stat(path),
            readlink: async (path) => { throw { code: 'ENOENT' }; },
            symlink: async () => {},
            backFile: async () => {}
        };

        for (const key in this.promises) {
            this.promises[key] = this.promises[key].bind(this);
        }
    }
  }

  global.LightningFS = LightningFS;

})(self);